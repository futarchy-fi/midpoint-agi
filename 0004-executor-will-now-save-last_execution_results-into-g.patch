From d48dc6b33490db2c1521e1b943a8cd689ae87cc7 Mon Sep 17 00:00:00 2001
From: krandder <azsantos.k@gmail.com>
Date: Mon, 14 Apr 2025 17:29:44 -0700
Subject: [PATCH 4/7] executor will now save last_execution_results into goal
 file

---
 docs/goal_cli.md                     |   6 +
 src/midpoint/agents/models.py        |   9 +-
 src/midpoint/agents/task_executor.py |  71 ++++-
 src/midpoint/goal_cli.py             | 449 +++++++++++++++++++++++----
 4 files changed, 454 insertions(+), 81 deletions(-)

diff --git a/docs/goal_cli.md b/docs/goal_cli.md
index 479596c..b40de9e 100644
--- a/docs/goal_cli.md
+++ b/docs/goal_cli.md
@@ -81,6 +81,12 @@ goal root
 goal subs
 ```
 
+#### Show code and memory diffs for a goal
+```bash
+goal diff <goal-id>
+```
+This command displays the `git diff` output between the initial and current states recorded for the specified goal, separately for the code repository and the memory repository (if configured and available in the goal's state). This is useful for understanding the exact changes made during the goal's execution.
+
 ### Result Incorporation
 
 #### Mark current goal as complete
diff --git a/src/midpoint/agents/models.py b/src/midpoint/agents/models.py
index 5f259fa..604669d 100644
--- a/src/midpoint/agents/models.py
+++ b/src/midpoint/agents/models.py
@@ -81,18 +81,19 @@ class ExecutionTrace:
 
 @dataclass
 class ExecutionResult:
-    """Represents the result of a task execution."""
+    """Represents the result of a task execution, including summary from the LLM."""
     success: bool  # Whether the execution was successful
     branch_name: str  # The git branch where execution occurred
     git_hash: str  # The git hash after execution
-    error_message: Optional[str] = None  # Error message if execution failed
+    summary: Optional[str] = None # LLM's summary of what was done or why it failed
+    suggested_validation_steps: Optional[List[str]] = None # LLM's suggested steps to validate (if successful)
+    error_message: Optional[str] = None  # System error message if execution failed unexpectedly
     execution_time: float = 0.0  # Time taken to execute the task
     repository_path: Optional[str] = None  # Path to the repository
     memory_repository_path: Optional[str] = None  # Path to the memory repository
     task_id: Optional[str] = None  # ID of the task that was executed
     goal_id: Optional[str] = None  # ID of the goal that was executed
-    validation_results: List[str] = field(default_factory=list)  # Results of validation steps
-    final_state: Optional['State'] = None  # Final state after execution (git_hash, memory_hash, etc.)
+    final_state: Optional['State'] = None  # Final state after execution (contains final git_hash, memory_hash, etc.)
 
 @dataclass
 class ValidationResult:
diff --git a/src/midpoint/agents/task_executor.py b/src/midpoint/agents/task_executor.py
index b67e9ed..01e7e97 100644
--- a/src/midpoint/agents/task_executor.py
+++ b/src/midpoint/agents/task_executor.py
@@ -360,54 +360,95 @@ Memory Hash: {memory_hash}"""
             # Execute the task
             result_json_str = self._execute_task_with_llm(user_prompt, context)
             
-            # Parse the result JSON to get the actual success status
+            # Parse the result JSON to get the actual success status and summary
             execution_success = False
-            error_message = "Unknown execution outcome"
+            summary = "Task execution failed internally."
+            validation_steps = []
+            error_message = "Unknown execution outcome" # Default error
+            final_git_hash = context.state.git_hash # Use initial hash as fallback
+
             try:
                 result_data = json.loads(result_json_str)
                 execution_success = result_data.get("success", False)
+                summary = result_data.get("summary", "No summary provided.")
+                # Ensure validation_steps is always a list
+                validation_steps = result_data.get("validation_steps") 
+                if validation_steps is None: # Handle null case
+                   validation_steps = []
+                elif not isinstance(validation_steps, list):
+                    # Attempt to handle non-list (e.g., string) - might need refinement
+                    validation_steps = [str(validation_steps)] 
+                    logger.warning("Validation steps were not a list, converted to list of strings.")
+                
+                # Get the final git hash reported by the LLM, if any
+                # This might represent the hash *after* a successful commit within the LLM flow
+                final_git_hash = result_data.get("git_hash") or context.state.git_hash
+
                 if not execution_success:
-                     error_message = result_data.get("summary") or result_data.get("error", "Task execution failed internally")
+                    # Use summary as error message if specifically marked as failure
+                    error_message = summary 
+                else:
+                    error_message = None # Clear error if success is true
+
             except json.JSONDecodeError as parse_error:
                 logger.error(f"Failed to parse final result JSON from _execute_task_with_llm: {parse_error}")
                 logger.error(f"Result string was: {result_json_str}")
-                error_message = "Failed to parse internal execution result"
+                summary = "Failed to parse LLM response JSON."
+                error_message = summary # Use parse failure as error message
                 execution_success = False # Ensure failure if JSON is bad
+                validation_steps = ["Failed to parse LLM response"] # Indicate failure reason
+            except Exception as e:
+                # Catch other potential errors during parsing/processing result_data
+                logger.error(f"Error processing LLM result data: {e}", exc_info=True)
+                summary = f"Error processing LLM result: {str(e)}"
+                error_message = summary
+                execution_success = False
+                validation_steps = ["Error processing LLM result"]
 
             # Get the current memory state if available
             current_memory_hash = None
             memory_repo_path = None
             
-            if context.memory_state:
+            # Determine memory path consistently
+            if hasattr(context, 'memory_state') and context.memory_state:
                 memory_repo_path = getattr(context.memory_state, "repository_path", None)
             if not memory_repo_path:
                 memory_repo_path = context.state.memory_repository_path
-            
+
+            # Get final memory hash
             if memory_repo_path:
                 try:
                     current_memory_hash = get_current_hash(memory_repo_path)
-                    logger.info(f"Updated memory hash: {current_memory_hash[:8]}")
+                    logger.info(f"Final memory hash after execution: {current_memory_hash[:8]}")
                 except Exception as e:
-                    logger.warning(f"Failed to get current memory hash: {e}")
+                    logger.warning(f"Failed to get final memory hash: {e}")
+                    # Use initial memory hash as fallback if final fetch fails
+                    current_memory_hash = context.state.memory_hash
+            else:
+                # If no memory repo path, use initial hash
+                current_memory_hash = context.state.memory_hash
             
-            # Create final state with updated memory hash
+            # Create final state using potentially updated hashes
             final_state = State(
-                git_hash=context.state.git_hash, # Note: This might be stale if commit failed
+                git_hash=final_git_hash, # Use hash reported by LLM or initial if missing
                 repository_path=context.state.repository_path,
-                description=context.state.description,
+                description="State after task execution attempt", # Generic description
                 branch_name=context.state.branch_name,
-                memory_hash=current_memory_hash,
+                memory_hash=current_memory_hash, # Use the hash obtained after execution attempt
                 memory_repository_path=memory_repo_path
             )
             
             # Return the result using the PARSED success status and include error message if failed
+            # Populate the new summary and validation_steps fields
             return ExecutionResult(
                 success=execution_success,
+                summary=summary, # Pass the summary from LLM
+                suggested_validation_steps=validation_steps, # Pass the validation steps
                 branch_name=context.state.branch_name,
-                git_hash=context.state.git_hash,
+                git_hash=final_git_hash, # Pass the potentially updated git hash
                 repository_path=context.state.repository_path,
-                final_state=final_state,
-                error_message=None if execution_success else error_message
+                final_state=final_state, # Include the final state object
+                error_message=error_message # Use derived error message
             )
             
         except Exception as e:
diff --git a/src/midpoint/goal_cli.py b/src/midpoint/goal_cli.py
index 89749ca..95b1309 100644
--- a/src/midpoint/goal_cli.py
+++ b/src/midpoint/goal_cli.py
@@ -1783,82 +1783,88 @@ def execute_task(task_id, debug=False, quiet=False, bypass_validation=False, no_
         
         # Create and run the executor
         executor = TaskExecutor()
-        result = executor.execute_task(context, task_data["description"])
-        
-        if result.success:
-            # Get current git hash
-            current_hash = get_current_hash()
-            if not current_hash:
-                logging.error("Failed to get current git hash")
-                return False
-            
-            # Get current memory hash if memory repository is available
-            memory_hash = None
-            memory_repo_path = task_data["initial_state"].get("memory_repository_path")
-            if memory_repo_path:
-                try:
-                    memory_hash = get_current_hash(memory_repo_path)
-                    logging.info(f"Updated memory hash: {memory_hash[:8]}")
-                except Exception as e:
-                    logging.warning(f"Failed to get updated memory hash: {e}")
-            
-            # Update task's current state
-            task_data["current_state"] = {
-                "git_hash": current_hash,
-                "repository_path": result.repository_path,
-                "description": f"State after executing task: {task_id}",
-                "timestamp": datetime.datetime.now().strftime("%Y%m%d_%H%M%S"),
-                "memory_hash": memory_hash or task_data["initial_state"].get("memory_hash"),
-                "memory_repository_path": memory_repo_path
-            }
-            
+        # The TaskExecutor now returns an enhanced ExecutionResult
+        execution_result: ExecutionResult = executor.execute_task(context, task_data["description"])
+
+        # --- Prepare the data for last_execution_result field ---
+        last_execution_data = {
+            "timestamp": datetime.datetime.now().strftime("%Y%m%d_%H%M%S"),
+            "success": execution_result.success,
+            "summary": execution_result.summary,
+            "suggested_validation_steps": execution_result.suggested_validation_steps,
+            "final_git_hash": execution_result.final_state.git_hash if execution_result.final_state else None,
+            "final_memory_hash": execution_result.final_state.memory_hash if execution_result.final_state else None,
+            "error_message": execution_result.error_message
+        }
+        # Remove null fields for cleaner output
+        last_execution_data = {k: v for k, v in last_execution_data.items() if v is not None}
+
+        # --- Update task_data regardless of success/failure --- 
+        # Overwrite or add the last_execution_result field
+        task_data["last_execution_result"] = last_execution_data
+
+        if execution_result.success:
+            logging.info(f"Task {task_id} execution reported success.")
+            # Use the final state returned by the executor
+            if execution_result.final_state:
+                task_data["current_state"] = {
+                    "git_hash": execution_result.final_state.git_hash,
+                    "repository_path": execution_result.final_state.repository_path,
+                    "description": f"State after successful execution: {task_id}",
+                    "timestamp": last_execution_data["timestamp"], # Use consistent timestamp
+                    "memory_hash": execution_result.final_state.memory_hash,
+                    "memory_repository_path": execution_result.final_state.memory_repository_path
+                }
+            else:
+                # Fallback if final_state wasn't provided for some reason
+                logging.warning("ExecutionResult was successful but missing final_state. Current state may be inaccurate.")
+                task_data["current_state"] = task_data.get("current_state", task_data["initial_state"]) # Keep old or initial
+                task_data["current_state"]["timestamp"] = last_execution_data["timestamp"]
+                task_data["current_state"]["description"] = f"State after execution (final_state missing): {task_id}"
+
             # Mark task as completed
             task_data["complete"] = True
-            task_data["completion_time"] = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
-            
+            task_data["completion_time"] = last_execution_data["timestamp"]
+
             # Save updated task data
-            with open(task_file, 'w') as f:
-                json.dump(task_data, f, indent=2)
-            
-            # Remove automatic parent state update
-            # parent_goal_id = task_data.get("parent_goal")
-            # if parent_goal_id:
-            #     update_parent_goal_state(
-            #         parent_goal_id=parent_goal_id,
-            #         task_id=task_id,
-            #         execution_result=result,
-            #         final_state=task_data["current_state"]
-            #     )
-            
-            print(f"\nTask {task_id} executed successfully")
-            if result.validation_results:
-                print(f"Result: {result.validation_results}")
+            try:
+                with open(task_file, 'w') as f:
+                    json.dump(task_data, f, indent=2)
+                logging.info(f"Saved updated task data for {task_id} (Success)")
+            except Exception as e:
+                logging.error(f"Failed to save successful task data for {task_id}: {e}")
+                # Even if save fails, we proceed to return True as execution succeeded
+
+            print(f"\nTask {task_id} executed successfully.")
+            print(f"Summary: {execution_result.summary}")
+            if execution_result.suggested_validation_steps:
+                 print("Suggested Validation Steps:")
+                 for step in execution_result.suggested_validation_steps:
+                     print(f"- {step}")
             return True
         else:
-            # --- START EDIT: Store failure information --- 
-            print(f"Failed to execute task: {result.error_message}", file=sys.stderr)
-            
-            # Update task data to reflect failure
+            logging.warning(f"Task {task_id} execution reported failure.")
+            print(f"Failed to execute task {task_id}: {execution_result.summary or execution_result.error_message}", file=sys.stderr)
+
+            # Update task data to reflect failure - keep current_state as it was before this failed attempt
             task_data["complete"] = False
             if "completion_time" in task_data:
                 del task_data["completion_time"] # Remove previous completion time if it exists
             
-            task_data["last_execution"] = {
-                "timestamp": datetime.datetime.now().strftime("%Y%m%d_%H%M%S"),
-                "success": False,
-                "summary": result.error_message or "Task execution failed with no specific error message."
-            }
-            
-            # Save updated task data
+            # The last_execution_result field is already updated above
+            # Remove the old 'last_execution' field if it exists
+            if "last_execution" in task_data:
+                del task_data["last_execution"]
+
+            # Save updated task data with failure status and last_execution_result
             try:
                 with open(task_file, 'w') as f:
                     json.dump(task_data, f, indent=2)
-                logging.info(f"Updated task file {task_file} with failure status.")
+                logging.info(f"Saved updated task data for {task_id} (Failure)")
             except Exception as e:
-                logging.error(f"Failed to write failure status to task file {task_file}: {e}")
-            # --- END EDIT --- 
+                logging.error(f"Failed to save failed task data for {task_id}: {e}")
             return False
-            
+
     finally:
         # Always restore the original branch and unstash changes
         try:
@@ -3663,5 +3669,324 @@ def analyze_goal(goal_id, human_mode):
         return False # Indicate failure
 
 
+def load_goal_data(goal_id: str) -> Optional[Dict[str, Any]]:
+    """Loads the JSON data for a given goal ID."""
+    goal_path = ensure_goal_dir()
+    goal_file = goal_path / f"{goal_id}.json"
+    if not goal_file.exists():
+        logging.error(f"Goal file not found for ID: {goal_id}")
+        return None
+    try:
+        with open(goal_file, 'r') as f:
+            return json.load(f)
+    except json.JSONDecodeError:
+        logging.error(f"Error decoding JSON from goal file: {goal_file}")
+        return None
+    except Exception as e:
+        logging.error(f"Error reading goal file {goal_file}: {e}")
+        return None
+
+def run_diff_command(repo_path: str, initial_hash: str, final_hash: str) -> Optional[str]:
+    """Runs 'git diff' in the specified repository and returns the output."""
+    if not repo_path or not os.path.exists(repo_path):
+        logging.warning(f"Repository path not found or not specified: {repo_path}")
+        return None
+    if not initial_hash or not final_hash:
+        logging.warning("Initial or final hash missing, cannot perform diff.")
+        return None
+    if initial_hash == final_hash:
+        logging.info(f"Initial and final hashes are the same ({initial_hash[:8]}) in {repo_path}. No changes.")
+        return "(No changes)"
+
+    # Use '..' notation which is standard for git diff range
+    # Add '--' to prevent ambiguity if hashes resemble filenames
+    command = ["git", "diff", f"{initial_hash}..{final_hash}", "--"]
+    logging.debug(f"Running diff in {repo_path}: {' '.join(command)}")
+    try:
+        # Using subprocess.run to capture output directly
+        result = subprocess.run(
+            command,
+            cwd=repo_path,
+            check=True,
+            capture_output=True,
+            text=True,
+            errors='ignore' # Ignore potential decoding errors in diff output
+        )
+        # Return stdout if it exists, otherwise indicate no textual changes
+        return result.stdout if result.stdout else "(No textual changes detected)"
+    except FileNotFoundError:
+         logging.error(f"Git command not found. Ensure Git is installed and in PATH.")
+         return f"Error: Git command not found in {repo_path}"
+    except subprocess.CalledProcessError as e:
+        logging.error(f"Error running git diff in {repo_path}: {e}")
+        logging.error(f"Stderr: {e.stderr}")
+        # Provide more context on error
+        error_message = f"Error running git diff in {repo_path}."
+        # Check stderr for common git diff errors
+        if "ambiguous argument" in e.stderr or "unknown revision" in e.stderr:
+             error_message += f" One of the hashes ({initial_hash[:8]}, {final_hash[:8]}) might be invalid or not found in this repository."
+        elif "fatal: bad object" in e.stderr:
+            error_message += f" One of the hashes ({initial_hash[:8]}, {final_hash[:8]}) is not a valid git object."
+        else:
+            # Include generic stderr if specific patterns don't match
+            error_message += f" Stderr: {e.stderr.strip()}"
+        return error_message
+    except Exception as e:
+        logging.error(f"Unexpected error running git diff in {repo_path}: {e}")
+        return f"Unexpected error during diff in {repo_path}: {e}"
+
+
+def show_goal_diffs(goal_id: str):
+    """Shows the code and memory diffs for a specific goal."""
+    logging.info(f"Showing diffs for goal: {goal_id}")
+    goal_data = load_goal_data(goal_id)
+    if not goal_data:
+        return # Error already logged by load_goal_data
+
+    initial_state = goal_data.get("initial_state")
+    current_state = goal_data.get("current_state")
+
+    if not initial_state or not current_state:
+        logging.error(f"Goal {goal_id} is missing initial or current state data.")
+        return
+
+    # Extract state information consistently from current_state where possible
+    initial_git_hash = initial_state.get("git_hash")
+    current_git_hash = current_state.get("git_hash")
+    # Prefer repository_path from current_state, fallback to initial
+    code_repo_path = current_state.get("repository_path") or initial_state.get("repository_path")
+
+    initial_memory_hash = initial_state.get("memory_hash")
+    current_memory_hash = current_state.get("memory_hash")
+    # Prefer memory_repository_path from current_state, fallback to initial
+    memory_repo_path = current_state.get("memory_repository_path") or initial_state.get("memory_repository_path")
+
+    print(f"--- Diffs for Goal: {goal_id} ('{goal_data.get('description', 'N/A')}') ---")
+    print(f"Initial State Timestamp: {initial_state.get('timestamp', 'N/A')}")
+    print(f"Current State Timestamp: {current_state.get('timestamp', 'N/A')}")
+
+    # --- Code Diff ---
+    print(f"\\n=== Code Repository Diff ({code_repo_path or 'Path unknown'}) ===")
+    print(f"Initial Hash: {initial_git_hash or 'N/A'}")
+    print(f"Final Hash:   {current_git_hash or 'N/A'}")
+    if code_repo_path and initial_git_hash and current_git_hash:
+        code_diff_output = run_diff_command(code_repo_path, initial_git_hash, current_git_hash)
+        print("\\n--- Git Diff Output ---")
+        # Check if output is None (error) or empty string/specific message
+        if code_diff_output is None:
+            print("Could not generate code diff due to previous error.")
+        elif code_diff_output == "(No changes)":
+             print(code_diff_output)
+        elif code_diff_output == "(No textual changes detected)":
+             print(code_diff_output)
+        elif "Error:" in code_diff_output: # Check if run_diff_command returned an error message
+             print(code_diff_output)
+        else:
+            print(code_diff_output) # Print the actual diff
+        print("--- End Git Diff ---")
+    else:
+        print("\\nSkipping code diff: Missing repository path or hashes.")
+
+    # --- Memory Diff ---
+    print(f"\\n=== Memory Repository Diff ({memory_repo_path or 'Path unknown'}) ===")
+    print(f"Initial Hash: {initial_memory_hash or 'N/A'}")
+    print(f"Final Hash:   {current_memory_hash or 'N/A'}")
+    if memory_repo_path and initial_memory_hash and current_memory_hash:
+        memory_diff_output = run_diff_command(memory_repo_path, initial_memory_hash, current_memory_hash)
+        print("\\n--- Git Diff Output (Memory) ---")
+        # Check if output is None (error) or empty string/specific message
+        if memory_diff_output is None:
+            print("Could not generate memory diff due to previous error.")
+        elif memory_diff_output == "(No changes)":
+             print(memory_diff_output)
+        elif memory_diff_output == "(No textual changes detected)":
+             print(memory_diff_output)
+        elif "Error:" in memory_diff_output: # Check if run_diff_command returned an error message
+             print(memory_diff_output)
+        else:
+            print(memory_diff_output) # Print the actual diff
+        print("--- End Git Diff (Memory) ---")
+    elif not memory_repo_path:
+         print("\\nSkipping memory diff: Memory repository path not configured or found in goal state.")
+    else: # Has path but missing hashes
+        print("\\nSkipping memory diff: Missing initial or final memory hash.")
+
+    print("\\n--- End Diffs ---")
+
+
+def main():
+    # Check if MEMORY_REPO_PATH is set and exists
+    memory_repo_path_env = os.environ.get("MEMORY_REPO_PATH")
+    if not memory_repo_path_env or not os.path.exists(memory_repo_path_env):
+        logging.warning(f"MEMORY_REPO_PATH environment variable not set or points to non-existent directory: {memory_repo_path_env}")
+
+    parser = argparse.ArgumentParser(description="Goal Management CLI")
+    subparsers = parser.add_subparsers(dest="command", help="Available commands")
+
+    # Add 'new' command
+    parser_new = subparsers.add_parser("new", help="Create a new top-level goal")
+    parser_new.add_argument("description", help="Description of the goal")
+    parser_new.set_defaults(func=lambda args: create_new_goal(args.description))
+
+    # Add 'sub' command
+    parser_sub = subparsers.add_parser("sub", help="Create a new subgoal")
+    parser_sub.add_argument("parent_id", help="ID of the parent goal")
+    parser_sub.add_argument("description", help="Description of the subgoal")
+    parser_sub.set_defaults(func=lambda args: create_new_subgoal(args.parent_id, args.description))
+
+    # Add 'task' command (deprecated but potentially kept for compatibility)
+    parser_task = subparsers.add_parser("task", help="DEPRECATED: Use 'sub'. Create a new task under a goal")
+    parser_task.add_argument("parent_id", help="ID of the parent goal")
+    parser_task.add_argument("description", help="Description of the task")
+    parser_task.set_defaults(func=lambda args: create_new_task(args.parent_id, args.description)) # Still maps to create_new_task
+
+    # Add 'list' command
+    parser_list = subparsers.add_parser("list", help="List all goals and subgoals")
+    parser_list.set_defaults(func=lambda args: list_goals())
+
+    # Add 'back' command
+    parser_back = subparsers.add_parser("back", help="Go back N commits on current branch (default: 1)")
+    parser_back.add_argument("steps", nargs='?', type=int, default=1, help="Number of commits to go back")
+    parser_back.set_defaults(func=lambda args: go_back_commits(args.steps))
+
+    # Add 'reset' command
+    parser_reset = subparsers.add_parser("reset", help="Reset to a specific commit on the current branch")
+    parser_reset.add_argument("commit_id", help="Commit hash to reset to")
+    parser_reset.set_defaults(func=lambda args: reset_to_commit(args.commit_id))
+
+    # Add 'up' command
+    parser_up = subparsers.add_parser("up", help="Go to the parent goal branch")
+    parser_up.set_defaults(func=lambda args: go_to_parent_goal())
+
+    # Add 'down' command
+    parser_down = subparsers.add_parser("down", help="Go to a specific subgoal branch")
+    parser_down.add_argument("subgoal_id", help="ID of the subgoal to navigate to")
+    parser_down.set_defaults(func=lambda args: go_to_child(args.subgoal_id))
+
+    # Add 'root' command
+    parser_root = subparsers.add_parser("root", help="Go to the top-level goal branch")
+    parser_root.set_defaults(func=lambda args: go_to_root_goal())
+
+    # Add 'subs' command
+    parser_subs = subparsers.add_parser("subs", help="List available subgoals for current goal")
+    parser_subs.set_defaults(func=lambda args: list_subgoals())
+
+    # Add 'complete' command
+    parser_complete = subparsers.add_parser("complete", help="Mark current goal as complete")
+    parser_complete.set_defaults(func=lambda args: mark_goal_complete())
+
+    # Add 'merge' command
+    parser_merge = subparsers.add_parser("merge", help="Merge a specific subgoal into the current goal")
+    parser_merge.add_argument("subgoal_id", help="ID of the subgoal to merge")
+    parser_merge.add_argument("--testing", action="store_true", help="Enable testing mode for merge")
+    parser_merge.set_defaults(func=lambda args: merge_subgoal(args.subgoal_id, args.testing))
+
+    # Add 'status' command
+    parser_status = subparsers.add_parser("status", help="Show completion status of all goals")
+    parser_status.set_defaults(func=lambda args: show_goal_status())
+
+    # Add 'tree' command
+    parser_tree = subparsers.add_parser("tree", help="Show visual representation of goal hierarchy")
+    parser_tree.set_defaults(func=lambda args: show_goal_tree())
+
+    # Add 'history' command
+    parser_history = subparsers.add_parser("history", help="Show timeline of goal exploration")
+    parser_history.set_defaults(func=lambda args: show_goal_history())
+
+    # Add 'graph' command
+    parser_graph = subparsers.add_parser("graph", help="Generate graphical visualization (requires Graphviz)")
+    parser_graph.set_defaults(func=lambda args: generate_graph())
+
+    # Add 'convert' command
+    parser_convert = subparsers.add_parser("convert", help="Convert legacy hierarchical goal IDs to flat IDs")
+    parser_convert.set_defaults(func=lambda args: logging.warning("Conversion command not implemented yet."))
+
+    # Add 'revert' command
+    parser_revert = subparsers.add_parser("revert", help="Revert a goal's current state back to its initial state")
+    parser_revert.add_argument("goal_id", help="The ID of the goal to revert")
+    parser_revert.set_defaults(func=lambda args: revert_goal(args.goal_id))
+
+    # Add 'solve' command (for decomposition and execution)
+    parser_solve = subparsers.add_parser("solve", help="Decompose and execute a goal (agent-driven)")
+    parser_solve.add_argument("goal_id", help="The ID of the goal to solve")
+    parser_solve.add_argument("--debug", action="store_true", help="Enable debug logging")
+    parser_solve.add_argument("--quiet", action="store_true", help="Suppress informational logging")
+    parser_solve.add_argument("--bypass-validation", action="store_true", help="Bypass automated validation")
+    parser_solve.add_argument("--no-commit", action="store_true", help="Prevent automatic commit after task execution")
+    parser_solve.add_argument("--memory-repo", help="Path to the memory repository (overrides env var)")
+    parser_solve.set_defaults(func=handle_solve_command)
+
+    # Add 'analyze' command
+    parser_analyze = subparsers.add_parser("analyze", help="Analyze a goal and create/update validation criteria")
+    parser_analyze.add_argument("goal_id", help="The ID of the goal to analyze")
+    parser_analyze.add_argument("--human-mode", action="store_true", help="Enable human-in-the-loop mode")
+    parser_analyze.set_defaults(func=lambda args: analyze_goal(args.goal_id, args.human_mode))
+
+    # Add 'validate' command (Manual trigger, likely uses GoalValidator internally)
+    parser_validate = subparsers.add_parser("validate", help="Manually trigger validation for a goal")
+    parser_validate.add_argument("goal_id", help="The ID of the goal to validate")
+    parser_validate.add_argument("--debug", action="store_true", help="Enable debug logging")
+    parser_validate.add_argument("--quiet", action="store_true", help="Suppress informational logging")
+    # Assuming validation might need the repo path if not easily inferable
+    parser_validate.add_argument("--repo-path", default=".", help="Path to the repository (default: current dir)")
+    parser_validate.set_defaults(func=lambda args: handle_validate_command(args)) # Need to create handle_validate_command
+
+    # Add 'update-parent' command (primarily for internal use)
+    parser_update_parent = subparsers.add_parser("update-parent", help="Update parent goal state (internal)")
+    parser_update_parent.add_argument("parent_id", help="Parent Goal ID")
+    parser_update_parent.add_argument("child_id", help="Child Goal/Task ID")
+    parser_update_parent.add_argument("status", choices=["success", "failure"], help="Status of the child")
+    parser_update_parent.set_defaults(func=handle_update_parent_command)
+
+    # Add 'validation-history' command
+    parser_validation_history = subparsers.add_parser("validation-history", help="Show validation history for a goal")
+    parser_validation_history.add_argument("goal_id", help="The ID of the goal")
+    parser_validation_history.add_argument("--debug", action="store_true", help="Enable debug logging")
+    parser_validation_history.add_argument("--quiet", action="store_true", help="Suppress informational logging")
+    parser_validation_history.set_defaults(func=lambda args: show_validation_history(args.goal_id, args.debug, args.quiet))
+
+    # Add 'delete' command
+    parser_delete = subparsers.add_parser("delete", help="Delete a goal and its associated branch and data")
+    parser_delete.add_argument("goal_id", help="The ID of the goal to delete")
+    parser_delete.set_defaults(func=lambda args: delete_goal(args.goal_id))
+
+    # Add 'diff' command
+    parser_diff = subparsers.add_parser("diff", help="Show code and memory diffs for a specific goal")
+    parser_diff.add_argument("goal_id", help="The ID of the goal (e.g., G1, S2)")
+    parser_diff.set_defaults(func=lambda args: show_goal_diffs(args.goal_id)) # Link to the new function
+
+    args = parser.parse_args()
+
+    # Set logging level based on args
+    if hasattr(args, 'debug') and args.debug:
+        logging.getLogger().setLevel(logging.DEBUG)
+    elif hasattr(args, 'quiet') and args.quiet:
+        logging.getLogger().setLevel(logging.WARNING)
+    else:
+         # Default level if neither debug nor quiet specified (or if command doesn't have these flags)
+         logging.getLogger().setLevel(logging.INFO)
+
+
+    if hasattr(args, "func"):
+        # Check if the function associated with the command is async
+        if asyncio.iscoroutinefunction(args.func):
+            try:
+                asyncio.run(args.func(args))
+            except Exception as e:
+                logging.error(f"Asynchronous command failed: {e}", exc_info=True)
+                sys.exit(1)
+        else:
+            # Execute synchronous function
+            try:
+                args.func(args)
+            except Exception as e:
+                logging.error(f"Command failed: {e}", exc_info=True)
+                sys.exit(1)
+    else:
+        # No command specified, or command doesn't map to a function
+        parser.print_help()
+        sys.exit(1)
+
+
 if __name__ == "__main__":
     main() 
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)

