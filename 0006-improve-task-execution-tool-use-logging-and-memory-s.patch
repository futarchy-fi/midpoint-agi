From 7064d45507c184230c1bc6a1fbd01796c2b87f48 Mon Sep 17 00:00:00 2001
From: krandder <azsantos.k@gmail.com>
Date: Mon, 14 Apr 2025 18:55:01 -0700
Subject: [PATCH 6/7] improve task execution tool use, logging and memory
 saving

---
 src/midpoint/agents/models.py             |   1 +
 src/midpoint/agents/task_executor.py      | 132 ++++++++++++--
 src/midpoint/agents/tools/code_tools.py   |   1 +
 src/midpoint/agents/tools/memory_tools.py |   2 +-
 src/midpoint/agents/tools/processor.py    |   8 +
 src/midpoint/goal_cli.py                  | 212 ++++++++++------------
 6 files changed, 220 insertions(+), 136 deletions(-)

diff --git a/src/midpoint/agents/models.py b/src/midpoint/agents/models.py
index 604669d..a39959e 100644
--- a/src/midpoint/agents/models.py
+++ b/src/midpoint/agents/models.py
@@ -94,6 +94,7 @@ class ExecutionResult:
     task_id: Optional[str] = None  # ID of the task that was executed
     goal_id: Optional[str] = None  # ID of the goal that was executed
     final_state: Optional['State'] = None  # Final state after execution (contains final git_hash, memory_hash, etc.)
+    metadata: Optional[Dict[str, Any]] = None # Generic metadata field (e.g., for tool usage)
 
 @dataclass
 class ValidationResult:
diff --git a/src/midpoint/agents/task_executor.py b/src/midpoint/agents/task_executor.py
index a06eaad..4090230 100644
--- a/src/midpoint/agents/task_executor.py
+++ b/src/midpoint/agents/task_executor.py
@@ -10,13 +10,14 @@ import asyncio
 import time
 import json
 import datetime
-from typing import List, Dict, Any, Optional
+from typing import List, Dict, Any, Optional, Tuple
 from dataclasses import dataclass
 import re
 import os
 import logging
 from pathlib import Path
 import subprocess
+import traceback
 
 from .models import TaskContext, ExecutionTrace, State, Goal, ExecutionResult
 from .tools import initialize_all_tools
@@ -173,11 +174,6 @@ class TaskExecutor:
                     content += f"## User Message\n\n{entry.get('user_prompt', '')}\n\n"
                 elif entry_type == "assistant_response":
                     content += f"## Assistant Response\n\n{entry.get('final_content', '')}\n\n"
-                elif entry_type == "tool_usage":
-                    tool_name = entry.get('tool_name', 'unknown_tool')
-                    tool_args = entry.get('tool_args', {})
-                    content += f"## Tool Usage: {tool_name}\n\n"
-                    content += f"Arguments: {json.dumps(tool_args, indent=2)}\n\n"
             
             # Add metadata
             content += "## Metadata\n\n"
@@ -348,7 +344,7 @@ Memory Repository: {context.state.memory_repository_path}
 Memory Hash: {context.state.memory_hash}"""
             
             # Execute the task
-            result_json_str = self._execute_task_with_llm(user_prompt, context)
+            result_json_str, tool_usage_list = self._execute_task_with_llm(user_prompt, context)
             
             # Parse the result JSON to get the actual success status and summary
             execution_success = False
@@ -430,6 +426,7 @@ Memory Hash: {context.state.memory_hash}"""
             
             # Return the result using the PARSED success status and include error message if failed
             # Populate the new summary and validation_steps fields
+            result_metadata = {"tool_usage": tool_usage_list}
             return ExecutionResult(
                 success=execution_success,
                 summary=summary, # Pass the summary from LLM
@@ -438,14 +435,51 @@ Memory Hash: {context.state.memory_hash}"""
                 git_hash=final_git_hash, # Pass the potentially updated git hash
                 repository_path=context.state.repository_path,
                 final_state=final_state, # Include the final state object
-                error_message=error_message # Use derived error message
+                error_message=error_message, # Use derived error message
+                metadata=result_metadata # Add the metadata field
             )
             
         except Exception as e:
             # This outer exception block catches errors *before* _execute_task_with_llm finishes
             logger.error(f"High-level error executing task: {str(e)}", exc_info=True)
+            # === EDIT: Return failure ExecutionResult with metadata if possible ===
+            # We might not have tool_usage if the error happened before _execute_task_with_llm finished
+            # Default to empty list if tool_usage_list is not defined in this scope
+            error_tool_usage = locals().get("tool_usage_list", [])
+            error_metadata = {"tool_usage": error_tool_usage, "error_details": traceback.format_exc()}
 
-    def _execute_task_with_llm(self, user_prompt: str, context: TaskContext) -> str:
+            # Try to construct a final state, may fail if context is incomplete
+            final_state = None
+            try:
+                current_memory_hash = context.state.memory_hash # Fallback
+                memory_repo_path = context.state.memory_repository_path # Fallback
+                if memory_repo_path:
+                     current_memory_hash = get_current_hash(memory_repo_path) or context.state.memory_hash
+                final_state = State(
+                    git_hash=context.state.git_hash, # Use initial hash
+                    repository_path=context.state.repository_path,
+                    description="State after high-level task execution error",
+                    branch_name=context.state.branch_name,
+                    memory_hash=current_memory_hash,
+                    memory_repository_path=memory_repo_path
+                )
+            except Exception as state_err:
+                 logger.error(f"Could not determine final state during high-level error handling: {state_err}")
+
+            return ExecutionResult(
+                success=False,
+                summary=f"High-level error during task execution: {str(e)}",
+                suggested_validation_steps=[],
+                branch_name=context.state.branch_name if context and context.state else "unknown",
+                git_hash=context.state.git_hash if context and context.state else "unknown",
+                repository_path=context.state.repository_path if context and context.state else "unknown",
+                final_state=final_state, # May be None
+                error_message=str(e),
+                metadata=error_metadata
+            )
+            # === END EDIT ===
+
+    def _execute_task_with_llm(self, user_prompt: str, context: TaskContext) -> Tuple[str, List[Any]]:
         """Execute a task using the LLM."""
         # Initialize messages
         messages = [
@@ -516,16 +550,71 @@ Memory Hash: {context.state.memory_hash}"""
             
             # Process tool calls and update tool usage
             if tool_calls:
+                logger.debug(f"Processing tool_calls: {tool_calls}") # DEBUG: Log the raw tool_calls list
                 for tool_call in tool_calls:
+                    logger.debug(f"  Processing individual tool_call: {tool_call}") # DEBUG: Log individual call
+                    logger.debug(f"  Type of tool_call: {type(tool_call)}") # DEBUG: Log type
                     tool_usage.append(tool_call)
-                    
+
                     # Record tool usage in conversation buffer
+                    # --- START EDIT ---
+                    # Correctly extract tool name and arguments, handling object/dict variations
+                    tool_name = 'unknown_tool' # Initialize
+                    tool_args_str = '{}' # Default to empty JSON string
+                    tool_args_parsed = {}
+                    logger.debug(f"  Initial tool_name: {tool_name}") # DEBUG
+                    try:
+                        # --- Check 1: Attribute access ---
+                        has_function_attr = hasattr(tool_call, 'function') and tool_call.function is not None
+                        logger.debug(f"  Checking hasattr(tool_call, 'function'): {has_function_attr}") # DEBUG
+                        if has_function_attr:
+                            tool_name = tool_call.function.name
+                            tool_args_str = tool_call.function.arguments # Arguments are typically JSON strings
+                            logger.debug(f"    Extracted via attributes: name={tool_name}, args_str={tool_args_str}") # DEBUG
+                        
+                        # --- Check 2: Dictionary access (if attribute access failed) ---
+                        elif isinstance(tool_call, dict):
+                            logger.debug(f"  Checking isinstance(tool_call, dict): True") # DEBUG
+                            # --- START REVISED DICT LOGIC ---
+                            # Directly access 'tool'/'name' and 'args'/'arguments' keys
+                            tool_name = tool_call.get('tool', tool_call.get('name', 'unknown_tool_dict_fallback')) # Check 'tool' first, then 'name'
+                            raw_args = tool_call.get('args', tool_call.get('arguments', {})) # Check 'args' first, then 'arguments'
+                            logger.debug(f"    Got raw_args: {raw_args}, type: {type(raw_args)}") # DEBUG
+                            
+                            # Arguments might be a string (JSON) or already a dict
+                            if isinstance(raw_args, str):
+                                tool_args_str = raw_args
+                            elif isinstance(raw_args, dict):
+                                tool_args_str = json.dumps(raw_args) # Convert dict back to JSON string for consistent parsing below
+                                logger.debug(f"    Converted dict args back to string: {tool_args_str}")
+                            else:
+                                logger.warning(f"    Unexpected type for args: {type(raw_args)}. Defaulting to empty dict.")
+                                tool_args_str = '{}' # Default if unexpected type
+                            # --- END REVISED DICT LOGIC ---
+                            logger.debug(f"    Extracted via dict: name={tool_name}, args_str={tool_args_str}") # DEBUG
+                        else:
+                            logger.warning(f"  Tool call is neither object with function nor dict: {tool_call}") # DEBUG
+
+                        # --- Argument Parsing ---
+                        logger.debug(f"  Attempting to parse args_str: {tool_args_str}") # DEBUG
+                        tool_args_parsed = json.loads(tool_args_str)
+                        logger.debug(f"    Successfully parsed args: {tool_args_parsed}") # DEBUG
+
+                    except Exception as e:
+                        # Log potential issues with accessing/parsing, but proceed
+                        logger.warning(f"Could not fully parse tool call info: {tool_call}. Error: {e}", exc_info=True) # Add traceback
+                        tool_args_parsed = {} # Use empty dict if parsing fails
+                        # Keep tool_name as it was potentially set before the error
+
+                    logger.debug(f"  Final tool_name before append: {tool_name}") # DEBUG
+                    logger.debug(f"  Final tool_args_parsed before append: {tool_args_parsed}") # DEBUG
                     self.conversation_buffer.append({
                         "type": "tool_usage",
-                        "tool_name": tool_call.get("name", "unknown_tool"),
-                        "tool_args": tool_call.get("arguments", {}),
+                        "tool_name": tool_name,
+                        "tool_args": tool_args_parsed, # Store parsed args if possible
                         "timestamp": datetime.datetime.now().isoformat()
                     })
+                    # --- END EDIT ---
             
             # Get the final assistant message content
             if isinstance(message, list):
@@ -574,7 +663,9 @@ Memory Hash: {context.state.memory_hash}"""
                         logger.info(f"  {i}. {step}")
                 # Save conversation BEFORE returning successfully
                 self._save_interaction_to_memory(context) # Sync call
-                return json.dumps(output_data)
+                # === EDIT: Return tool_usage list ===
+                return final_content, tool_usage
+                # === END EDIT ===
             else:
                 # Handle failure (JSON invalid or missing fields)
                 error_reason = "LLM response missing required fields or invalid JSON"
@@ -589,7 +680,9 @@ Memory Hash: {context.state.memory_hash}"""
                 }
                 # Save conversation BEFORE returning failure
                 self._save_interaction_to_memory(context) # Sync call
-                return json.dumps(default_response)
+                # === EDIT: Return tool_usage list ===
+                return json.dumps(default_response), tool_usage
+                # === END EDIT ===
             
         except Exception as e:
             # Log the general error
@@ -601,6 +694,17 @@ Memory Hash: {context.state.memory_hash}"""
             except Exception as save_error:
                 logger.error(f"Failed to save conversation on error: {str(save_error)}")
 
+            # === EDIT: Return default error JSON and tool_usage list ===
+            # Return a default error JSON structure if an exception occurs
+            default_error_response = {
+                 "summary": f"Task failed with exception: {str(e)}",
+                 "success": False,
+                 "validation_steps": [f"Task execution failed due to exception: {str(e)}"],
+                 "error": str(e)
+            }
+            return json.dumps(default_error_response), tool_usage
+            # === END EDIT ===
+
     def is_git_ancestor(self, repo_path: str, ancestor_hash: str, descendant_hash: str) -> bool:
         """
         Check if one hash is an ancestor of another in a git repository.
diff --git a/src/midpoint/agents/tools/code_tools.py b/src/midpoint/agents/tools/code_tools.py
index fc42db2..e15d6fb 100644
--- a/src/midpoint/agents/tools/code_tools.py
+++ b/src/midpoint/agents/tools/code_tools.py
@@ -9,6 +9,7 @@ import re
 import asyncio
 import logging
 import platform
+import subprocess
 from typing import List, Dict, Any, Optional
 
 from .base import Tool
diff --git a/src/midpoint/agents/tools/memory_tools.py b/src/midpoint/agents/tools/memory_tools.py
index ca6ad59..db5b9a5 100644
--- a/src/midpoint/agents/tools/memory_tools.py
+++ b/src/midpoint/agents/tools/memory_tools.py
@@ -522,7 +522,7 @@ def retrieve_recent_memory(memory_hash, char_limit=5000, repo_path=None):
             except Exception as e:
                 logging.warning(f"Memory: Failed to restore original branch: {str(e)}") 
 
-async def get_memory_diff(initial_hash: str, final_hash: str, memory_repo_path: str = None, max_size: int = 50000) -> Dict[str, Any]:
+def get_memory_diff(initial_hash: str, final_hash: str, memory_repo_path: str = None, max_size: int = 50000) -> Dict[str, Any]:
     """
     Get a diff between two memory repository states.
     
diff --git a/src/midpoint/agents/tools/processor.py b/src/midpoint/agents/tools/processor.py
index 7e9a85f..a1c12f3 100644
--- a/src/midpoint/agents/tools/processor.py
+++ b/src/midpoint/agents/tools/processor.py
@@ -284,6 +284,14 @@ class ToolProcessor:
                 else:
                     result_str = str(result)
                 
+                # === START: Truncate search_code output ===
+                MAX_OUTPUT_LENGTH = 10000 # Approx 2500 tokens
+                if function_name == "search_code" and len(result_str) > MAX_OUTPUT_LENGTH:
+                    truncated_output = result_str[:MAX_OUTPUT_LENGTH] + "\n\n[...truncated...]"
+                    logging.warning(f"Truncated {function_name} output from {len(result_str)} to {len(truncated_output)} characters.")
+                    result_str = truncated_output
+                # === END: Truncate search_code output ===
+                
                 # Add to responses
                 tool_responses.append({
                     "role": "tool",
diff --git a/src/midpoint/goal_cli.py b/src/midpoint/goal_cli.py
index c8bc172..c32a02c 100644
--- a/src/midpoint/goal_cli.py
+++ b/src/midpoint/goal_cli.py
@@ -14,12 +14,14 @@ from pathlib import Path
 from typing import Optional, List, Dict, Any, Tuple
 import sys
 import time
+import shutil
 
 # Local imports (ensure correct relative paths)
 from .agents.models import Goal, SubgoalPlan, TaskContext, ExecutionResult, MemoryState, State
 from .agents.goal_decomposer import decompose_goal as agent_decompose_goal
 from .agents.task_executor import TaskExecutor, configure_logging as configure_executor_logging
-from .agents.tools.git_tools import get_current_hash, get_current_branch
+from .agents.tools.git_tools import get_current_hash, get_current_branch, get_repository_diff
+from .agents.tools.memory_tools import get_memory_diff # Corrected import source
 
 # Import validator for automated validation
 from .agents.goal_validator import GoalValidator
@@ -1805,28 +1807,13 @@ def execute_task(task_id, debug=False, quiet=False, bypass_validation=False, no_
 
         if execution_result.success:
             logging.info(f"Task {task_id} execution reported success.")
-            # Use the final state returned by the executor
-            if execution_result.final_state:
-                task_data["current_state"] = {
-                    "git_hash": execution_result.final_state.git_hash,
-                    "repository_path": execution_result.final_state.repository_path,
-                    "description": f"State after successful execution: {task_id}",
-                    "timestamp": last_execution_data["timestamp"], # Use consistent timestamp
-                    "memory_hash": execution_result.final_state.memory_hash,
-                    "memory_repository_path": execution_result.final_state.memory_repository_path
-                }
-            else:
-                # Fallback if final_state wasn't provided for some reason
-                logging.warning("ExecutionResult was successful but missing final_state. Current state may be inaccurate.")
-                task_data["current_state"] = task_data.get("current_state", task_data["initial_state"]) # Keep old or initial
-                task_data["current_state"]["timestamp"] = last_execution_data["timestamp"]
-                task_data["current_state"]["description"] = f"State after execution (final_state missing): {task_id}"
-
-            # Mark task as completed
+            
+            # Still mark task as completed conceptually upon successful execution report
+            # (Though actual merging/acceptance is separate)
             task_data["complete"] = True
             task_data["completion_time"] = last_execution_data["timestamp"]
 
-            # Save updated task data
+            # Save updated task data (now only updates complete, completion_time, and last_execution_result)
             try:
                 with open(task_file, 'w') as f:
                     json.dump(task_data, f, indent=2)
@@ -3670,76 +3657,29 @@ def analyze_goal(goal_id, human_mode):
 
 
 def load_goal_data(goal_id: str) -> Optional[Dict[str, Any]]:
-    """Loads the JSON data for a given goal ID."""
+    """Load goal data from the JSON file."""
     goal_path = ensure_goal_dir()
     goal_file = goal_path / f"{goal_id}.json"
     if not goal_file.exists():
-        logging.error(f"Goal file not found for ID: {goal_id}")
+        logging.error(f"Goal file not found: {goal_file}")
         return None
     try:
         with open(goal_file, 'r') as f:
             return json.load(f)
-    except json.JSONDecodeError:
-        logging.error(f"Error decoding JSON from goal file: {goal_file}")
-        return None
     except Exception as e:
         logging.error(f"Error reading goal file {goal_file}: {e}")
         return None
 
-def run_diff_command(repo_path: str, initial_hash: str, final_hash: str) -> Optional[str]:
-    """Runs 'git diff' in the specified repository and returns the output."""
-    if not repo_path or not os.path.exists(repo_path):
-        logging.warning(f"Repository path not found or not specified: {repo_path}")
-        return None
-    if not initial_hash or not final_hash:
-        logging.warning("Initial or final hash missing, cannot perform diff.")
-        return None
-    if initial_hash == final_hash:
-        logging.info(f"Initial and final hashes are the same ({initial_hash[:8]}) in {repo_path}. No changes.")
-        return "(No changes)"
-
-    # Use '..' notation which is standard for git diff range
-    # Add '--' to prevent ambiguity if hashes resemble filenames
-    command = ["git", "diff", f"{initial_hash}..{final_hash}", "--"]
-    logging.debug(f"Running diff in {repo_path}: {' '.join(command)}")
-    try:
-        # Using subprocess.run to capture output directly
-        result = subprocess.run(
-            command,
-            cwd=repo_path,
-            check=True,
-            capture_output=True,
-            text=True,
-            errors='ignore' # Ignore potential decoding errors in diff output
-        )
-        # Return stdout if it exists, otherwise indicate no textual changes
-        return result.stdout if result.stdout else "(No textual changes detected)"
-    except FileNotFoundError:
-         logging.error(f"Git command not found. Ensure Git is installed and in PATH.")
-         return f"Error: Git command not found in {repo_path}"
-    except subprocess.CalledProcessError as e:
-        logging.error(f"Error running git diff in {repo_path}: {e}")
-        logging.error(f"Stderr: {e.stderr}")
-        # Provide more context on error
-        error_message = f"Error running git diff in {repo_path}."
-        # Check stderr for common git diff errors
-        if "ambiguous argument" in e.stderr or "unknown revision" in e.stderr:
-             error_message += f" One of the hashes ({initial_hash[:8]}, {final_hash[:8]}) might be invalid or not found in this repository."
-        elif "fatal: bad object" in e.stderr:
-            error_message += f" One of the hashes ({initial_hash[:8]}, {final_hash[:8]}) is not a valid git object."
-        else:
-            # Include generic stderr if specific patterns don't match
-            error_message += f" Stderr: {e.stderr.strip()}"
-        return error_message
-    except Exception as e:
-        logging.error(f"Unexpected error running git diff in {repo_path}: {e}")
-        return f"Unexpected error during diff in {repo_path}: {e}"
-
+def show_goal_diffs(goal_id: str, show_code: bool = True, show_memory: bool = False):
+    """Shows code and/or memory diffs for a specific goal, comparing initial state
+    against both current state and the last execution result if available.
 
-def show_goal_diffs(goal_id: str):
-    """Shows code and memory diffs for a specific goal, comparing initial state 
-    against both current state and the last execution result if available."""
-    logging.info(f"Showing diffs for goal: {goal_id}")
+    Args:
+        goal_id: The ID of the goal.
+        show_code: Whether to display the code repository diff.
+        show_memory: Whether to display the memory repository diff.
+    """
+    logging.info(f"Showing diffs for goal: {goal_id} (code: {show_code}, memory: {show_memory})")
     goal_data = load_goal_data(goal_id)
     if not goal_data:
         return # Error already logged
@@ -3752,7 +3692,7 @@ def show_goal_diffs(goal_id: str):
         logging.error(f"Goal {goal_id} is missing initial state data. Cannot compute diffs.")
         return
 
-    # --- Extract Initial State Info --- 
+    # --- Extract Initial State Info ---
     initial_git_hash = initial_state.get("git_hash")
     initial_memory_hash = initial_state.get("memory_hash")
     initial_timestamp = initial_state.get('timestamp', 'N/A')
@@ -3760,7 +3700,7 @@ def show_goal_diffs(goal_id: str):
     base_code_repo_path = initial_state.get("repository_path")
     base_memory_repo_path = initial_state.get("memory_repository_path")
 
-    # --- Check for State Diff --- 
+    # --- Check for State Diff ---
     state_diff_exists = False
     current_git_hash = None
     current_memory_hash = None
@@ -3775,12 +3715,12 @@ def show_goal_diffs(goal_id: str):
         # Prefer paths from current_state if available
         state_code_repo_path = current_state.get("repository_path") or base_code_repo_path
         state_memory_repo_path = current_state.get("memory_repository_path") or base_memory_repo_path
-        
+
         if (initial_git_hash and current_git_hash and initial_git_hash != current_git_hash) or \
            (initial_memory_hash and current_memory_hash and initial_memory_hash != current_memory_hash):
             state_diff_exists = True
 
-    # --- Check for Execution Diff --- 
+    # --- Check for Execution Diff ---
     execution_diff_exists = False
     exec_final_git_hash = None
     exec_final_memory_hash = None
@@ -3791,12 +3731,12 @@ def show_goal_diffs(goal_id: str):
         exec_final_git_hash = last_execution.get("final_git_hash")
         exec_final_memory_hash = last_execution.get("final_memory_hash")
         exec_timestamp = last_execution.get('timestamp', 'N/A')
-        
+
         if (initial_git_hash and exec_final_git_hash and initial_git_hash != exec_final_git_hash) or \
            (initial_memory_hash and exec_final_memory_hash and initial_memory_hash != exec_final_memory_hash):
             execution_diff_exists = True
 
-    # --- Display Header --- 
+    # --- Display Header ---
     print(f"--- Diffs for Goal: {goal_id} ('{goal_data.get('description', 'N/A')}') ---")
     print(f"Initial State Timestamp: {initial_timestamp}")
     if state_diff_exists:
@@ -3804,57 +3744,77 @@ def show_goal_diffs(goal_id: str):
     if execution_diff_exists:
         print(f"Last Execution Timestamp: {exec_timestamp}")
 
-    # --- Function to print a specific diff type --- 
-    def print_diff(diff_type_label: str, start_hash_git: str, end_hash_git: str, 
-                     start_hash_mem: str, end_hash_mem: str, 
+    # --- Function to print a specific diff type ---
+    def print_diff(diff_type_label: str, start_hash_git: str, end_hash_git: str,
+                     start_hash_mem: str, end_hash_mem: str,
                      code_repo_path: str, memory_repo_path: str):
         print(f"\n=== {diff_type_label} ===")
-        # Code Diff
-        print(f"\n--- Code Repository Diff ({code_repo_path or 'Path unknown'}) --- ")
-        print(f"Initial Hash: {start_hash_git or 'N/A'}")
-        print(f"Final Hash:   {end_hash_git or 'N/A'}")
-        if code_repo_path and start_hash_git and end_hash_git:
-            code_diff_output = run_diff_command(code_repo_path, start_hash_git, end_hash_git)
-            print("\nDiff Output:")
-            print(code_diff_output if code_diff_output is not None else "Error generating diff.")
-        else:
-            print("\nSkipping code diff: Missing repository path or necessary hashes.")
-
-        # Memory Diff
-        print(f"\n--- Memory Repository Diff ({memory_repo_path or 'Path unknown'}) --- ")
-        print(f"Initial Hash: {start_hash_mem or 'N/A'}")
-        print(f"Final Hash:   {end_hash_mem or 'N/A'}")
-        if memory_repo_path and start_hash_mem and end_hash_mem:
-            memory_diff_output = run_diff_command(memory_repo_path, start_hash_mem, end_hash_mem)
-            print("\nDiff Output (Memory):")
-            print(memory_diff_output if memory_diff_output is not None else "Error generating diff.")
-        elif not memory_repo_path:
-            print("\nSkipping memory diff: Memory repository path not configured or found.")
-        else:
-            print("\nSkipping memory diff: Missing necessary memory hashes.")
-        print("--- End Diff --- ")
 
-    # --- Display Logic --- 
+        # Code Diff (Conditional)
+        if show_code:
+            print(f"\n--- Code Repository Diff ({code_repo_path or 'Path unknown'}) --- ")
+            print(f"Initial Hash: {start_hash_git or 'N/A'}")
+            print(f"Final Hash:   {end_hash_git or 'N/A'}")
+            if code_repo_path and start_hash_git and end_hash_git:
+                try:
+                    diff_result = get_repository_diff(code_repo_path, start_hash_git, end_hash_git)
+                    print("\nDiff Output:")
+                    print(diff_result.get("diff_content", "Error: Could not get diff content."))
+                    if diff_result.get("truncated", False):
+                        print("[Diff truncated due to size limit]")
+                except Exception as e:
+                    print(f"\nError generating code diff: {e}")
+            else:
+                print("\nSkipping code diff: Missing repository path or necessary hashes.")
+        elif not show_memory: # If neither is shown, print a message
+             print("\n(Code diff display skipped by flags)")
+
+        # Memory Diff (Conditional)
+        if show_memory:
+            print(f"\n--- Memory Repository Diff ({memory_repo_path or 'Path unknown'}) --- ")
+            print(f"Initial Hash: {start_hash_mem or 'N/A'}")
+            print(f"Final Hash:   {end_hash_mem or 'N/A'}")
+            if memory_repo_path and start_hash_mem and end_hash_mem:
+                try:
+                    diff_result = get_memory_diff(initial_hash=start_hash_mem, final_hash=end_hash_mem, memory_repo_path=memory_repo_path)
+                    print("\nDiff Output (Memory):")
+                    print(diff_result.get("diff_content", "Error: Could not get diff content."))
+                    if diff_result.get("truncated", False):
+                        print("[Diff truncated due to size limit]")
+                except Exception as e:
+                     print(f"\nError generating memory diff: {e}")
+            elif not memory_repo_path:
+                print("\nSkipping memory diff: Memory repository path not configured or found.")
+            else:
+                print("\nSkipping memory diff: Missing necessary memory hashes.")
+        elif not show_code: # If neither is shown, print a message
+             print("\n(Memory diff display skipped by flags)")
+
+        # Only print End Diff if at least one diff was attempted
+        if show_code or show_memory:
+            print("--- End Diff --- ")
+
+    # --- Display Logic ---
     if state_diff_exists and execution_diff_exists:
         print("\nShowing both State diff (Initial vs Current) and Execution diff (Initial vs Last Execution).")
-        print_diff("State Diff (Initial vs Current)", 
-                   initial_git_hash, current_git_hash, 
+        print_diff("State Diff (Initial vs Current)",
+                   initial_git_hash, current_git_hash,
                    initial_memory_hash, current_memory_hash,
                    state_code_repo_path, state_memory_repo_path)
-        print_diff("Execution Diff (Initial vs Last Execution)", 
-                   initial_git_hash, exec_final_git_hash, 
+        print_diff("Execution Diff (Initial vs Last Execution)",
+                   initial_git_hash, exec_final_git_hash,
                    initial_memory_hash, exec_final_memory_hash,
                    base_code_repo_path, base_memory_repo_path) # Use base paths for execution diff
     elif state_diff_exists:
         print("\nShowing State diff (Initial vs Current). No different execution result found.")
-        print_diff("State Diff (Initial vs Current)", 
-                   initial_git_hash, current_git_hash, 
+        print_diff("State Diff (Initial vs Current)",
+                   initial_git_hash, current_git_hash,
                    initial_memory_hash, current_memory_hash,
                    state_code_repo_path, state_memory_repo_path)
     elif execution_diff_exists:
         print("\nShowing Execution diff (Initial vs Last Execution). State hashes have not changed.")
-        print_diff("Execution Diff (Initial vs Last Execution)", 
-                   initial_git_hash, exec_final_git_hash, 
+        print_diff("Execution Diff (Initial vs Last Execution)",
+                   initial_git_hash, exec_final_git_hash,
                    initial_memory_hash, exec_final_memory_hash,
                    base_code_repo_path, base_memory_repo_path) # Use base paths for execution diff
     else:
@@ -4008,7 +3968,17 @@ def main():
     # Add 'diff' command
     parser_diff = subparsers.add_parser("diff", help="Show code and memory diffs for a specific goal")
     parser_diff.add_argument("goal_id", help="The ID of the goal (e.g., G1, S2)")
-    parser_diff.set_defaults(func=lambda args: show_goal_diffs(args.goal_id)) # Link to the new function
+    # Add mutually exclusive group for diff modes
+    mode_group = parser_diff.add_mutually_exclusive_group()
+    mode_group.add_argument("--code", action="store_true", help="Show only code diff (default)")
+    mode_group.add_argument("--memory", action="store_true", help="Show only memory diff")
+    mode_group.add_argument("--complete", action="store_true", help="Show both code and memory diffs")
+    # Set defaults based on flags
+    parser_diff.set_defaults(func=lambda args: show_goal_diffs(
+                                 args.goal_id,
+                                 show_code=(args.code or args.complete or not (args.memory or args.complete)), # Default to True if no flag set
+                                 show_memory=(args.memory or args.complete)
+                             ))
 
     # Add 'execute' command (direct task execution)
     parser_execute = subparsers.add_parser("execute", help="Directly execute a specific task (bypasses solve loop)")
-- 
2.39.5 (Apple Git-154)

