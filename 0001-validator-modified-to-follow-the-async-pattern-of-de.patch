From c355301cc001ff2f7f041e1b765e5ec295322c16 Mon Sep 17 00:00:00 2001
From: krandder <azsantos.k@gmail.com>
Date: Mon, 14 Apr 2025 17:00:59 -0700
Subject: [PATCH 1/7] validator modified to follow the async pattern of
 decomposer and other agents

---
 src/midpoint/agents/goal_validator.py | 273 ++++++++++++++++----------
 1 file changed, 173 insertions(+), 100 deletions(-)

diff --git a/src/midpoint/agents/goal_validator.py b/src/midpoint/agents/goal_validator.py
index d1d6810..96bbf16 100644
--- a/src/midpoint/agents/goal_validator.py
+++ b/src/midpoint/agents/goal_validator.py
@@ -6,7 +6,6 @@ task execution results. It MUST NOT contain any task-specific logic or hardcoded
 All validation decisions should be made by the LLM at runtime.
 """
 
-import asyncio
 import json
 import logging
 import re
@@ -15,7 +14,6 @@ from typing import List, Dict, Any, Optional, Tuple
 import os
 import random
 from pathlib import Path
-import subprocess
 
 from openai import AsyncOpenAI
 
@@ -30,8 +28,6 @@ from .tools import (
     web_search,
     web_scrape
 )
-# Import validate_repository_state from goal_decomposer
-from .goal_decomposer import validate_repository_state
 from .tools.processor import ToolProcessor
 from .tools.registry import ToolRegistry
 from .config import get_openai_api_key
@@ -150,13 +146,12 @@ Your response must be in JSON format with these fields:
         # Get tools from registry
         self.tools = ToolRegistry.get_tool_schemas()
 
-    async def validate_execution(self, goal: Goal, execution_result: ExecutionResult) -> ValidationResult:
+    def validate_execution(self, goal: Goal, execution_result: ExecutionResult) -> ValidationResult:
         """
         Validate execution results against a goal using LLM.
         
-        This method takes a goal and execution result and validates the execution
-        results against the goal using an LLM. This method handles repository
-        state validation and content validation.
+        NOTE: This synchronous method relies on its caller providing an asyncio event loop
+        because it internally calls async helper functions/tools.
         
         Args:
             goal: The goal to validate
@@ -180,23 +175,30 @@ Your response must be in JSON format with these fields:
         # Validate repository state
         repo_info = {}
         try:
-            current_branch = await get_current_branch(execution_result.repository_path)
+            # Call async helper directly, relies on caller's loop
+            current_branch = get_current_branch(execution_result.repository_path)
             if current_branch != execution_result.branch_name:
                 logging.info(f"Current branch {current_branch} does not match execution branch {execution_result.branch_name}")
-                # Try to switch to correct branch using subprocess
+                # Try to switch to correct branch using run_terminal_cmd tool
                 try:
-                    proc = subprocess.run(
-                        ["git", "checkout", execution_result.branch_name],
+                    checkout_cmd = f"git checkout {execution_result.branch_name}"
+                    logging.info(f"Attempting tool call: run_terminal_cmd '{checkout_cmd}'")
+                    # Call async tool directly, relies on caller's loop
+                    tool_response = run_terminal_cmd(
+                        command=checkout_cmd,
                         cwd=execution_result.repository_path,
-                        capture_output=True,
-                        text=True
+                        is_background=False
                     )
-                    if proc.returncode == 0:
-                        logging.info(f"Switched to branch {execution_result.branch_name}")
+
+                    if tool_response and tool_response.get("stdout") is not None:
+                        logging.info(f"Switched to branch {execution_result.branch_name} via tool")
+                        current_branch = execution_result.branch_name
                     else:
-                        raise ValueError(f"Failed to checkout branch: {proc.stderr}")
+                        error_detail = tool_response.get("stderr", "No error detail") if tool_response else "Tool call failed"
+                        raise ValueError(f"Failed to checkout branch using tool: {error_detail}")
+
                 except Exception as e:
-                    logging.error(f"Failed to switch to branch {execution_result.branch_name}: {e}")
+                    logging.error(f"Failed to switch to branch {execution_result.branch_name} using tool: {e}")
                     # Return failed validation
                     return ValidationResult(
                         goal_id=goal.id,
@@ -209,7 +211,8 @@ Your response must be in JSON format with these fields:
                     )
         
             # Get repository info
-            current_hash = await get_current_hash(execution_result.repository_path)
+            # Call async helper directly, relies on caller's loop
+            current_hash = get_current_hash(execution_result.repository_path)
             repo_info = {
                 "git_hash": current_hash,
                 "branch_name": current_branch,
@@ -225,42 +228,55 @@ Your response must be in JSON format with these fields:
             if (hasattr(goal, 'initial_state') and goal.initial_state and 
                 hasattr(goal.initial_state, 'git_hash') and goal.initial_state.git_hash):
                 initial_hash = goal.initial_state.git_hash
-                # Using a different approach to get the diff since get_diff is not available
-                proc = subprocess.run(
-                    ["git", "diff", initial_hash, current_hash],
-                    cwd=execution_result.repository_path,
-                    capture_output=True,
-                    text=True
-                )
-                if proc.returncode == 0:
-                    repo_diff = proc.stdout if proc.stdout.strip() else "No repository changes detected"
-                    
-                    # Auto-fail if repo diff is too large (over 100KB)
-                    if len(repo_diff) > 100000:
-                        logging.warning(f"Repository diff is too large ({len(repo_diff)} bytes). Auto-failing validation.")
-                        failed_criteria = []
-                        for criterion in goal.validation_criteria:
-                            failed_criteria.append(
-                                CriterionResult(
-                                    criterion=criterion,
-                                    passed=False,
-                                    reasoning="Validation failed due to repository changes being too large to validate",
-                                    evidence=["Repository diff exceeded maximum size (100KB)"]
+                # Using run_terminal_cmd tool to get the diff
+                try:
+                    diff_cmd = f"git diff {initial_hash} {current_hash} | cat"
+                    logging.info(f"Attempting tool call: run_terminal_cmd '{diff_cmd[:100]}...'")
+                    # Call async tool directly, relies on caller's loop
+                    tool_response = run_terminal_cmd(
+                        command=diff_cmd,
+                        cwd=execution_result.repository_path,
+                        is_background=False
+                    )
+
+                    if tool_response and tool_response.get("stdout") is not None:
+                        diff_output = tool_response["stdout"]
+                        repo_diff = diff_output if diff_output.strip() else "No repository changes detected"
+                        logging.info(f"Successfully got repo diff via tool (length: {len(repo_diff)})")
+
+                        # Auto-fail if repo diff is too large (over 100KB)
+                        if len(repo_diff) > 100000:
+                            logging.warning(f"Repository diff is too large ({len(repo_diff)} bytes). Auto-failing validation.")
+                            failed_criteria = []
+                            for criterion in goal.validation_criteria:
+                                failed_criteria.append(
+                                    CriterionResult(
+                                        criterion=criterion,
+                                        passed=False,
+                                        reasoning="Validation failed due to repository changes being too large to validate",
+                                        evidence=["Repository diff exceeded maximum size (100KB)"]
+                                    )
                                 )
+                            return ValidationResult(
+                                goal_id=goal.id,
+                                timestamp=datetime.now().strftime("%Y%m%d_%H%M%S"),
+                                criteria_results=failed_criteria,
+                                score=0.0,
+                                validated_by="System",
+                                automated=True,
+                                repository_state=State(**repo_info) if repo_info else None,
+                                reasoning="Repository changes were too large to validate"
                             )
-                        return ValidationResult(
-                            goal_id=goal.id,
-                            timestamp=datetime.now().strftime("%Y%m%d_%H%M%S"),
-                            criteria_results=failed_criteria,
-                            score=0.0,
-                            validated_by="System",
-                            automated=True,
-                            repository_state=State(**repo_info) if repo_info else None,
-                            reasoning="Repository changes were too large to validate"
-                        )
+                    else:
+                         error_detail = tool_response.get("stderr", "No error detail") if tool_response else "Tool call failed"
+                         raise ValueError(f"Failed to get repo diff using tool: {error_detail}")
+
+                except Exception as e:
+                    logging.error(f"Failed to get repo diff using tool: {e}")
+                    repo_diff = f"Error getting repository diff via tool: {str(e)}"
         except Exception as e:
-            logging.error(f"Failed to get repo diff: {e}")
-            repo_diff = f"Error getting repository diff: {str(e)}"
+            logging.error(f"Failed preparation for repo diff: {e}")
+            repo_diff = f"Error preparing for repository diff: {str(e)}"
         
         memory_diff_content = "No memory changes detected"
         memory_diff_files = []
@@ -269,58 +285,86 @@ Your response must be in JSON format with these fields:
                 hasattr(goal.initial_state, 'memory_hash') and goal.initial_state.memory_hash and
                 hasattr(goal, 'current_state') and goal.current_state and
                 hasattr(goal.current_state, 'memory_hash') and goal.current_state.memory_hash):
-                memory_diff = await get_memory_diff(goal.initial_state.memory_hash, 
+                # Call async helper directly, relies on caller's loop
+                memory_diff = get_memory_diff(goal.initial_state.memory_hash, 
                                             goal.current_state.memory_hash,
                                             execution_result.repository_path)
                 
                 if memory_diff:
                     memory_diff_content = memory_diff.get('diff_content', 'No memory changes detected')
                     memory_diff_files = memory_diff.get('changed_files', [])
+                    memory_repo_path = memory_diff.get('memory_repo_path', execution_result.repository_path)
                     
-                    # If memory hashes are different but no changes detected, something's wrong
-                    # Add details about the changed files
                     if (memory_diff_content == "No memory changes detected" or not memory_diff_content.strip()) and \
                        goal.initial_state.memory_hash != goal.current_state.memory_hash:
                         logging.warning(f"Memory hashes differ ({goal.initial_state.memory_hash} vs {goal.current_state.memory_hash}) but no diff content found")
                         
-                        # Get the content of any changed files
                         if memory_diff_files:
-                            memory_repo_path = memory_diff.get('memory_repo_path', execution_result.repository_path)
                             additional_content = ["Memory hashes differ but standard diff shows no changes. Showing file contents instead:"]
-                            
-                            for file_path in memory_diff_files:
-                                try:
-                                    # Save current state
-                                    current_branch = await get_current_branch(memory_repo_path)
-                                    
-                                    # Try to checkout the final hash to read files
-                                    checkout_proc = subprocess.run(
-                                        ["git", "checkout", goal.current_state.memory_hash],
-                                        cwd=memory_repo_path,
-                                        capture_output=True,
-                                        text=True
-                                    )
-                                    
-                                    if checkout_proc.returncode == 0:
-                                        # Try to read the file content
-                                        file_full_path = os.path.join(memory_repo_path, file_path)
-                                        if os.path.exists(file_full_path):
-                                            with open(file_full_path, 'r') as f:
-                                                file_content = f.read()
+                            original_memory_branch = None
+                            try:
+                                # Call async helper directly, relies on caller's loop
+                                original_memory_branch = get_current_branch(memory_repo_path)
+
+                                # Try to checkout the final hash to read files using tools
+                                checkout_cmd = f"git checkout {goal.current_state.memory_hash}"
+                                logging.info(f"Attempting tool call: run_terminal_cmd '{checkout_cmd}' in {memory_repo_path}")
+                                # Call async tool directly, relies on caller's loop
+                                tool_response_checkout = run_terminal_cmd(
+                                    command=checkout_cmd,
+                                    cwd=memory_repo_path,
+                                    is_background=False
+                                )
+
+                                if tool_response_checkout and tool_response_checkout.get("stdout") is not None:
+                                    logging.info(f"Checked out memory hash {goal.current_state.memory_hash} via tool")
+                                    # Try to read each file content using read_file tool
+                                    for file_path in memory_diff_files:
+                                        try:
+                                            file_full_path_in_memory_repo = os.path.join(memory_repo_path, file_path)
+
+                                            logging.info(f"Attempting tool call: read_file '{file_full_path_in_memory_repo}'")
+                                            # Call async tool directly, relies on caller's loop
+                                            file_content_data = read_file(
+                                                target_file=file_full_path_in_memory_repo,
+                                                should_read_entire_file=True,
+                                                start_line_one_indexed=1,
+                                                end_line_one_indexed_inclusive=1
+                                            )
+
+                                            file_content = file_content_data.get("file_contents", f"Error reading file {file_path}")
+
                                             additional_content.append(f"\n--- FILE: {file_path} ---\n{file_content}")
-                                    
-                                    # Restore original branch
-                                    subprocess.run(
-                                        ["git", "checkout", current_branch],
-                                        cwd=memory_repo_path,
-                                        capture_output=True,
-                                        text=True
-                                    )
-                                except Exception as file_error:
-                                    logging.error(f"Error reading changed file {file_path}: {file_error}")
-                                    additional_content.append(f"Error reading {file_path}: {str(file_error)}")
-                        
-                            if len(additional_content) > 1:  # If we have any file content
+                                            logging.info(f"Read file {file_path} via tool")
+
+                                        except Exception as file_error:
+                                            logging.error(f"Error reading changed file {file_path} using tool: {file_error}")
+                                            additional_content.append(f"Error reading {file_path}: {str(file_error)}")
+                                else:
+                                    error_detail = tool_response_checkout.get("stderr", "Checkout failed") if tool_response_checkout else "Checkout failed"
+                                    logging.error(f"Failed to checkout memory hash {goal.current_state.memory_hash} using tool: {error_detail}")
+                                    additional_content.append(f"Error: Could not checkout memory state {goal.current_state.memory_hash} to read files.")
+
+                            except Exception as outer_error:
+                                 logging.error(f"Error during memory file reading process: {outer_error}")
+                                 additional_content.append(f"Error accessing memory state for file reads: {str(outer_error)}")
+                            finally:
+                                # Always try to restore original branch in memory repo
+                                if original_memory_branch:
+                                    try:
+                                        restore_cmd = f"git checkout {original_memory_branch}"
+                                        logging.info(f"Attempting tool call: run_terminal_cmd '{restore_cmd}' in {memory_repo_path}")
+                                        # Call async tool directly, relies on caller's loop
+                                        run_terminal_cmd(
+                                            command=restore_cmd,
+                                            cwd=memory_repo_path,
+                                            is_background=False
+                                        )
+                                        logging.info(f"Restored memory repo branch to {original_memory_branch} via tool")
+                                    except Exception as restore_error:
+                                        logging.error(f"Failed to restore memory repo branch to {original_memory_branch} using tool: {restore_error}")
+
+                            if len(additional_content) > 1:  # If we have any file content or errors
                                 memory_diff_content = "\n".join(additional_content)
             
                     # Auto-fail if memory diff is too large (over 100KB)
@@ -383,6 +427,7 @@ Your response must be in JSON format with these fields:
             )
         
         # Prepare context for LLM
+        additional_evidence_section = "" # Placeholder if needed in future
         messages = [
             {"role": "system", "content": VALIDATION_SYSTEM_PROMPT},
             {"role": "user", "content": f"""
@@ -423,7 +468,8 @@ Only validate based on the evidence provided from previous execution.
         
         try:
             # Use the LLM to validate the goal
-            validation_response = await self._validate_with_tools(goal, messages)
+            # Call sync helper which internally calls async tool processor
+            validation_response = self._validate_with_tools(goal, messages)
             
             # Log the raw response for debugging
             logging.info(f"Raw validation response (first 200 chars): {validation_response[:200] if validation_response else 'empty'}")
@@ -556,10 +602,13 @@ Only validate based on the evidence provided from previous execution.
         
         return "\n".join(reasoning)
 
-    async def validate_goal(self, goal_path: str, repository_path: str = ".") -> ValidationResult:
+    def validate_goal(self, goal_path: str, repository_path: str = ".") -> ValidationResult:
         """
         Validate a goal using a dummy execution result.
         
+        NOTE: This synchronous method relies on its caller providing an asyncio event loop
+        for the internal calls to async helpers and self.validate_execution.
+        
         Args:
             goal_path: Path to the goal JSON file
             repository_path: Path to the repository
@@ -588,6 +637,10 @@ Only validate based on the evidence provided from previous execution.
             logging.debug(f"Initial hash: {initial_git_hash}")
             logging.debug(f"Current hash: {current_git_hash}")
             
+            # Get current branch name for ExecutionResult
+            # Call async helper directly, relies on caller's loop
+            current_branch_name = get_current_branch(repository_path)
+
             # Create Goal object
             goal = Goal(
                 id=goal_data.get('goal_id', ''),
@@ -610,15 +663,15 @@ Only validate based on the evidence provided from previous execution.
             execution_result = ExecutionResult(
                 success=True,
                 repository_path=repository_path,
-                branch_name=get_current_branch(repository_path),
+                branch_name=current_branch_name,
                 git_hash=current_git_hash,
                 task_id='',
                 goal_id=goal_data.get('goal_id', ''),
                 error_message=None
             )
             
-            # Validate execution
-            return await self.validate_execution(goal, execution_result)
+            # Validate execution (sync call)
+            return self.validate_execution(goal, execution_result)
         except Exception as e:
             logging.error(f"Error validating goal: {e}")
             raise
@@ -835,10 +888,14 @@ Only validate based on the evidence provided from previous execution.
         logging.warning("No valid JSON validation response could be processed")
         return {"criteria_results": []} 
 
-    async def _validate_with_tools(self, goal: Goal, messages: List[Dict[str, str]]) -> str:
+    # Keep this method synchronous
+    def _validate_with_tools(self, goal: Goal, messages: List[Dict[str, str]]) -> str:
         """
         Use LLM with tools to validate a goal.
         
+        NOTE: This synchronous method relies on its caller providing an asyncio event loop
+        for the internal call to self.tool_processor.run_llm_with_tools.
+        
         Args:
             goal: The goal to validate
             messages: The messages to send to the LLM, including system prompt and user query
@@ -849,7 +906,8 @@ Only validate based on the evidence provided from previous execution.
         logging.info(f"Validating goal {goal.id} with LLM")
         
         # Run LLM with tools
-        response, tool_calls = await self.tool_processor.run_llm_with_tools(
+        # Call async tool processor directly, relies on caller's loop
+        response, tool_calls = self.tool_processor.run_llm_with_tools(
             messages=messages,
             model=self.model
         )
@@ -870,10 +928,25 @@ Only validate based on the evidence provided from previous execution.
             # Create a description of tools used, for debugging purposes
             tool_descriptions = []
             for i, tool_call in enumerate(tool_calls):
-                if tool_call.get("tool") and tool_call.get("args"):
-                    tool_name = tool_call.get("tool")
-                    args = tool_call.get("args", {})
+                if isinstance(tool_call, dict) and 'function' in tool_call:
+                    tool_name = tool_call['function'].get('name', 'unknown_tool')
+                    args_str = tool_call['function'].get('arguments', '{}')
+                    try:
+                        args = json.loads(args_str)
+                    except json.JSONDecodeError:
+                        args = {"raw_arguments": args_str}
+
                     tool_descriptions.append(f"Used tool: {tool_name} with arguments: {json.dumps(args)}")
+                elif hasattr(tool_call, 'function') and hasattr(tool_call.function, 'name') and hasattr(tool_call.function, 'arguments'):
+                     tool_name = tool_call.function.name
+                     args_str = tool_call.function.arguments
+                     try:
+                         args = json.loads(args_str)
+                     except json.JSONDecodeError:
+                         args = {"raw_arguments": args_str}
+                     tool_descriptions.append(f"Used tool: {tool_name} with arguments: {json.dumps(args)}")
+                else:
+                     tool_descriptions.append(f"Used unknown tool: {str(tool_call)}")
             
             # Return a validation response indicating tool usage isn't valid for validation
             return json.dumps({
-- 
2.39.5 (Apple Git-154)

