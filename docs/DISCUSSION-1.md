There are several things I would like to discuss regarding the GoalDecomposer, before we move on to implementing the other agents.

(1). The first is that it focus too much on decomposing into multiple steps. However, the only important thing according to our @VISION.md is to decide the next step. This is because after the first step is executed *and validated* and summarized, we'll get a new state, including a new commit and a new git hash. So if the initial state is "A", the final state (desired final goal) is "S", and after our first successfully executed task we reached state "B", the GoalDecomposer will be called again to plan what to do, but this time it will be called to move from ["B" to "S"] instead of from ["A" to "S"] as previously. Therefore, the most important thing is thinking well about what will the next measurable step be, and what are the requirements for validating that the next milestone was achieved, not planning all the steps ahead until the final goal.

In particular, it should be very much encouraged for the first step for achieving any important, complex final goal to be a study session, or other ways of gathering information, and it is not necessary for there to be a final beginning-to-end plan right at the beginning. We really only need to realize what seems most promising about the next step.

(2) The second thing that I would like to discuss, is that this "point management system" is not implemented in the way I'd like it to be. It is not supposed to "distribute" points among several steps. So I don't like how this is looking. Instead, what I wanted to do is something more akin to AlphaZero's MCTS strategy, where we'll be first do a tree search (using some heuristic) and latter do a "rollout" to see if the subgoal can be achieved (in the execution step). Maybe honestly we should ignore this completely and remove all mentions of point systems and all implementations of points, and just let our "search" algorithm run for as long as we want to until it succeeds, or until we manually delete it, or maybe define in the main loop a maximum number of calls until we stop.

(3) The third very important point, is that while the executor will later have access to a variety of tools to implement/execute the subgoals, it seems like the GoalDecomposer doesn't have enough information to decide what the next subgoals should be. It receives a git hash for the current state but is unable to take a look into what exactly is in this hash, or calling any other tools to decide what to do. This seems very wrong, as it seems very important for the agent to be able to do some "exploration" of what is the current situation in the "Current State" before it can define what seems most promising to "try next". Not really what what we are supposed to do about it.
